# 复习

[TOC]



## ※各层次区别&&每层的协议

![image-20210109235011682](D:\software\Typora\iamge\image-20210109235011682.png)

## ※计算机网络和因特网

![image-20210112165630901](D:\software\Typora\iamge\image-20210112165630901.png)

![image-20210112165456847](D:\software\Typora\iamge\image-20210112165456847.png)

### 1.1 什么是因特网(组成、功能)

#### 1.1.1 组成描述

> 因特网是一个世界范围的计算机网络，这意味着它互联了数以亿计的计算设备；这些设备包括但不限于传统PC、工作站、路由器、手机、无线链路等。
>
> 所有连入因特网的设备都叫做**主机或者端系统**
>
> **端系统**通过**通信链路**和**分组交换机**连接到一起。链路系统就是用来传输分组的。分组到达接收端系统后，接收端系统将根据必要信息来抽取用户数据；
>
> 分组交换机从它的一条入链路接收分组，并且选择一条出链路将分组转发出去；
>
>  分组交换机有**路由器**和**链路层交换机**；链路层交换机主要用在接入网中，路由器主要用在网络核心.
>
> 端系统通过**因特网服务提供商ISP（**Internet Service Provider）接入因特网；
>
> 协议有：**TCP（Transport Control Protocol，传输控制协议）和IP(Internet Protocol，网际协议)**；因为协议控制了信息的传递，所以对协议达成一致就很重要，所以需要一个标准来规范协议，以便创造可以协同工作的系统和产品

 

#### 1.1.2 服务描述

> 应用程序编程接口（API)

#### ※1.1.3 协议

⭐**协议:**定义了两个或多个通信实体（不一定是端系统，还有可能是分组交换机等）之间交换信息的格式和次序以及对该信息所采取的动作

 凡是通信实体的所有活动都要受到协议的约束。比如，硬件实现的控制协议控制了两块网卡之间的比特流；在端系统中，拥塞控制协议控制了发送方和接收方之间传输数据的速率等

### 1.2 网络的边缘（包括什么）理解

 **端系统**：与因特网相连的计算机和其它设备，往往处于网络的边缘

 端系统：客户和服务器

 **接入网**：是指将端系统连入到边缘路由器的物理链路

 **边缘路由器**：是指端系统到任何其他远程端系统路径上的第一台路由器

  接入网络

- DSL(Digital Subscribe Line)电话线接入

- CIC(Cable Internet Access)电缆因特网接入

- 光纤接入

- 无线接入网络
  - LANS无线局域网(同一建筑)
  - 广域无线接入

### 1.3 网络核心（理解）

 网络核心即为由互联端系统的分组交换机和链路构成的网状网络

 通过网络链路和交换机移动数据有两种基本方法：电路交换和分组交换

#### 1.3.1 分组交换

> 分组在通信链路上以等于该链路的最大传输速率传输通过通信链路。因此如果某条链路的最大传输速率为R，分组长度为L，则该链路传输该分组的时间为L/R；这个时间也被称为传输时延（值得注意的是，这里说的时间很有可能是传播时延而不是传输时延，这两者的区别在关于延迟时间的计算中将详细解释，虽然这里书上写的是传输，但是根据后文，我认为是传播）；分组交换的常见方式是存储转发机制；

- 存储转发

  <img src="D:\software\Typora\iamge\image-20210112150954015.png" alt="image-20210112150954015" style="zoom:67%;" />

大多数分组交换机采用存储转发机制来转发分组；所谓存储转发是指交换机在收到一个完成的分组，才会向链路输出转发分组，否则就将收到的部分分组缓存起来；因为缓存等待一个分组的全部数据而导致的时间开销被称为存储转发时延。

分组传输延迟=L/R 端到端时延2L/R

- 排队时延与分组丢失

因为需要缓存分组，所以此时分组交换机需要一个输出缓存和输出队列；缓冲队列的空间有限性就有可能导致分组交换机无法继续缓存分组（因为链路被占用或者分组还没全部到位）而使到达分组交换机的数据包被迫丢弃。

- 转发表与路由选择协议

实际上，分组交换机之所以能够知道往哪去是因为其内部有一个**转发表**，这个表维护了一个IP地址和链路的对应关系，所以处理流程为：

1. 通过分组的必要信息，获得目的端系统的IP地址
2. 通过IP地址索引转发表，从而确定输出链路

#### 1.3.4 网络结构-网络的网络

ISP(internet service provider)译为互联网服务提供商

端系统是通过ISP接入因特网的，为了实现端系统的互联，ISP也必须互联，其实网络模型就是用来表达ISP和端系统以及ISP之间的结构的抽象；

三层ISP结构分为主干ISP，地区ISP，本地ISP。本地ISP给用户提供最直接的服务，本地ISP可以连接到地区ISP，也可以连接到主干ISP。

![image-20210112155016829](D:\software\Typora\iamge\image-20210112155016829.png)

总体来说，今天的因特网是一个“网络的网络”，其结构复杂，由十多个顶层ISP和数十万个较低层ISP构成。近年来，主要的内容提供商创建自己的网络，直接在可能的地方与较低层ISP互联

### 1.4 分组交换中的时延、丢包

因特网能够看成是一种运行在端系统上的分布式应用提供服务的基础设施

计算机网络必定要要限制在端系统之间的吞吐量，故在端系统之间存在时延、丢包；

#### 1.4.1 分组交换网中的时延概述

**传输时延和传播时延的对比**

如果打个比方的话，传输时延就是大卡车经过收费站的时间；传播时延就是车在高速公路上行驶的时间。传输时延是分组长度和链路传输速率的函数。传播时延是两台路由器间距离的函数

#### 1.4.2 时延和丢包

**丢包：**到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失

![image-20210112151931076](D:\software\Typora\iamge\image-20210112151931076.png)

- 处理时延proc：差错检测；确定输出链路；小于微妙

- 排队时延queue：等待输出链路可用。取决于路由器拥塞程度，与La/R成正比(0,<1,>1)

  ![image-20210112152434544](D:\software\Typora\iamge\image-20210112152434544.png)

- 传输时延trans：L（分组长度）/ R（链路带宽 传输速率)
  传输时延是将所有分组的比特推向链路所有需要的时间

- 传播时延prop：从该链路的起点到下一个结点所用的时间；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器
  传播时延是d/s。d是路由器A到B的距离(链路长度)。s是链路的传播速率。

为了描述网络状体，我们引入了流量强度这一概念：流量强度=分组到达的速度/结点的处理速度；流量工程里一个金科玉律就是：设计系统时流量强度不能大于1；

当**流量强度**持续大于1时，就将出现丢包现象

#### 1.4.3 端到端时延(没有排队)

> ![image-20210112152642400](D:\software\Typora\iamge\image-20210112152642400.png)

### 1.5 协议层次及其服务模型

#### 1.5.1 分层体系结构

总体来说，将各层的所有协议组合起来，称为**协议栈**。因特网的协议栈有5个层次组成**：物理层、链路层、网络层、传输层、应用层**

  **应用层**：应用层协议分布在多个端系统，端系统中的应用程序使用该协议与另一个端系统中的应用程序通信。处于应用层的分组称为**报文**；
  **传输层**：传输层在**应用程序端点之间**传输应用层报文，因特网中有两个传输层协议：TCP和UDP。处于传输层的分组称为**报文段**。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供无连接服务，即不提供不必要服务的服务。没有可靠性、没有流量和拥塞控制。
  **网络层**：网络层将称为数据报的网络层分组从**一台主机移动到另一台主机**。网络层协议包含著名的IP协议以及其他一些路由选择协议。**数据报**
  **链路层**：链路层将称为**帧的链路层分组从一个结点移动到路径上的另一个端点**。一个帧可能被沿途不同链路上的不同链路层协议处理。**帧**
  **物理层**：物理层的任务是将**帧中的比特从一个结点移动到下一个节点**，它提供了传输信息的实际物理通道；

M->Ht | M-> Hn | Ht | M -> Hl | Hn | Ht | M

- OSI模型

在因特网协议栈出现以前，OSI模型是ISO组织研发的计算机网络结构模型。OSI的模型一共有7层，从下到上依次为：物理层，链路层，网络层，传输层，**会话层，表示层**，应用层。相比因特网体系结构，OSI多了两层。

因特网将两层的功能留给了开发者自行实现。



#### **1.5.2 封装**

> 一个分组，在不同的层次有不同的称谓，是因为它们经过每一层的时候就被该层封装上了属于该层的相关信息，也就是前面提到的必要信息；于是，每一分层的分组有两种类型的字段：首部字段和有效负载；其中有效负载即为来自上一层的分组数据，而首部字段就是该层加上的必要信息；分组不断被封装以实现各层协议规定的相关功能

### ※1.6 网络攻击和安全

### ※病毒、蠕虫

![image-20210112154526638](D:\software\Typora\iamge\image-20210112154526638.png)

### ※DDos

利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。

![image-20210112154552218](D:\software\Typora\iamge\image-20210112154552218.png)

 

## ※第五层：应用层（协议作用、哪个用TCP哪个UDP）

![image-20210110014623718](D:\software\Typora\iamge\image-20210110014623718.png)

![image-20210110015143283](D:\software\Typora\iamge\image-20210110015143283.png)

<img src="D:\software\Typora\iamge\image-20210110015219386.png" alt="image-20210110015219386" style="zoom:67%;" />

![image-20210110013225063](D:\software\Typora\iamge\image-20210110013225063.png)

![img](D:\software\Typora\iamge\20190324183705231.png)

### 2.1 应用层协议原理

> 研发网络应用的核心是写出能够运行在不同端系统和通过网络彼此通信的程序；值得注意的是，我们不需要写在网络核心设备如路由器或者链路层交换机上运行的软件，这种设计方式即将应用程序限制在端系统的方法，促进了大量网络应用程序的迅速研发和部署

#### 2.2.1 网络应用程序体系结构

> 应用程序的体系结构不同于网络的体系结构。应用程序体系结构是用应用程序开发设计的，它规定了在端系统上如何组织应用程序。两种常见的现代网络应用程序所采用的体系结构为：**客户-服务器体系结构和P2P体系结构**

- 客户-服务器体系结构

在该体系结构中，有一个**总是打开**的主机，即服务器，它接收和服务来自其他许多被称为客户的主机请求,服务器具有固定的、周知的地址,是数据中心；

在该体系结构中，**客户之间是不直接通信**的，客户有动态IP，客户与服务器间断链接；

客户-服务器体系结构的著名应用有：**Web、FTP、Telnet和电子邮件**。

- P2P体系结构

应用程序在间断连接的**主机对之间使用直接通信**，这些主机被称为**对等**方。对等方并不为服务提供商所拥有，因为这种对等方通信不需要通过专门的服务器，所以该体系结构也被称为对等方到对等方结构

目前，**流量密集型应用**都是P2P体系结构的。这些应用包括**文件共享**（例如BitTorrent）、协助下载（例如迅雷）、因特网电话（例如Skype）和**IPTV**(例如迅雷看看)。

**自扩展性**。比如在文件共享应用中，对等方可能通过向文件的原始拥有者发出请求而产生工作量，但是对等方也有可能通过为其他对等方传送文件而为原始拥有者分担压力；P2P体系结构也是成本有效的，因为他通常不需要庞大的服务器基础设施和服务带宽。

**但是P2P也面临着以下三个问题：**

1.   难于管理。

2.   ISP友好。大多数住宅ISP受制于非对称带宽应用，也就是下载比上传要多得多。但是P2P视频和文件分发应用改变了从服务器到住宅ISP的上载流量，因而给ISP带来压力；

3.   安全性。因为其高度的分布和开放式，P2P应用也可能给安全带来挑战；

- 混合。

结合了客户-服务器和P2P这两种体系结果，比如许多的即时通讯工具，服务器用来跟踪用户IP地址，但是用户之间的通信则使用直接发送

#### 2.1.2 进程通信

- 客户进程和服务器进程

![image-20210112121102484](D:\software\Typora\iamge\image-20210112121102484.png)

在某些P2P应用中，一个进程可能既是客户也是服务器。

**首先发起通信的进程被标记为客户进程，在会话开始时等待联系的进程被称为服务器进程。**

- 进程与计算机网络之间的接口socket

套接字是同一台主机内应用层和运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也被称为应用程序和网络之间的**应用编程接口API**（Application Programming Interface）.

为了向特定目的进程发送报文，发送机进程需要知道接收进程（更为准确的说是，接收进程对应的套接字）的标记。该标记由两部分组成：**IP地址+端口号**；其中IP地址是一个32位（IPV4）标记；一些常用的应用程序有着固定的端口号：

​	HTTP Server:80

​	Mail Server（运行SMTP协议）:25

####  2.1.3 可供应用程序使用的运输服务

> 传输层协议的特点大致可以从以下这四个方面考量：可靠数据传输、吞吐量、定时和安全性

- 可靠数据传输**确保应用程序一段发送的数据正确、完全地交付给接收数据的进程**。

- 吞吐量

可用吞吐量就是指能够向接收进程交付比特的速率。对吞吐量有明确要求的应用程序被称为**带宽敏感的应用**,比如因特网电话。而**弹性应用**则对吞吐量没有严格的要求,包括：电子邮件、文件传输以及web传送等。

- 定时。定时是对数据从发送到到达所需时间的要求，常见的应用有：因特网电话、多方在线游戏等；

- 安全性

#### ※2.1.4 因特网提供的传输层服务

因特网（更一般的是TCP/IP网络）为应用程序提供连个运输层协议，即UDP和TCP。每个协议对应用程序提供了不同服务的组合。以下为常见的因特网应用的特点：
![img](D:\software\Typora\iamge\20190324190800412.png)

- 运输层无法对吞吐量和定时做出保证。但是，今天的因特网能够为时间敏感的应用提供满意的服务，尽管它并不提供任何定时或者带宽保证；

  <img src="D:\software\Typora\iamge\image-20210112123115177.png" alt="image-20210112123115177" style="zoom:70%;" />

#### 2.1.6 应用层协议

应用层协议是网络应用的一部分

### ※2.2 WEB和HTTP（怎么去访问一个网站——）

#### 2.2.1 HTTP概述

HTTP（HyperText Transfer Protocol）超文本传输协议。是WEB的应用层协议，它是Web的核心；HTTP有两部分实现，一个客户端程序一个服务器程序；HTTP定义了客户和服务器进行报文交换的方法；

HTTP使用**TCP**作为它的传输层协议；HTTP客户首先发起一个与服务器的TCP连接，需要注意的是，服务器根据请求作出响应，但是不存储任何关于该客户的状态信息；也正因为这样，HTTP被称为**无状态协议**。同时，Web使用了客户端-服务器的应用体系结构；其中web服务器总是开着的。

#### ※2.2.2 持续连接和非持续连接

当通信是使用TCP协议时，服务器端需要做出一个决定：这些请求是使用一个TCP连接完成还是通过独立的TCP连接完成。如果采取前一个方法，则称应用程序使用**持续连接**，如果使用后一种方式，则称为**非持续连接**。

HTTP既可使用持续连接也可以使用非持续连接。尽管**HTTP在默认情况下使用持续连接**

- 采用非持续连接的HTTP

使用非持续连接时，每个TCP连接在服务器发送一个对象后就会关闭，也就是每个TCP只传送一个请求报文和响应报文；

- 采用持续连接的HTTP

如果使用持续连接，那么服务器在发送响应报文后将保持该TCP打开，后续客户端可以使用该连接来向服务器发出请求。不但一个完整的页面可以通过同一个连接传送，同一台服务器上的多个页面也可以通过同一个连接发送。这就提高了效率；

一般来说，如果一条连接在一定的时间间隔后没被使用的话，就会被关闭。HTTP默认使用的是带流水线的持续连接。

-   用户端系统保留一个Cookie文件，由浏览器保存维护；

-  **FTP**： **需要在整个会话期间，保留用户的状态**。

### ※2.3因特网中的电子邮件

 

因特网电子邮件系统有三个核心组件：**用户代理**、**邮件服务器**、**SMTP**（简单邮件传输协议，Simple Mail Transfer Protocol）。

每个收发方在邮件服务器上拥有一个邮箱；一个典型的电子邮件发送为：发送方通过用户代理将邮件传送到发送方的邮件服务器，然后再传输到接收方的邮件服务器，然后邮件被分发到接收方的邮箱里；接收方从邮件服务器里获取自己的邮件时需要通过邮件服务器的验证

#### ※2.3.1 SMTP

SMTP是因特网中电子邮件的主要应用层协议，它使用**TCP**可靠数据传输从发送方的邮件服务器向接收方的邮件服务器发送邮件。

如果发送端不能将邮件发送个接受端的服务器，发送端的邮件服务器会在一个报文队列中保持该报文并在以后尝试再次发送。

**传输的三个阶段**：握手、传输、关闭连接。

SMTP25号端口。SMTP是**持续连接**的。命令响应交互模式。

值得注意的是，SMTP报文一般**不使用中间邮件服务器发送报文**，也就是邮件不会在中间某个邮件服务器保留；在SMTP握手阶段，SMTP客户端将介绍发送方和接收方的邮箱地址；一旦介绍完毕后，SMTP客户端将开始发送报文

![img](D:\software\Typora\iamge\{FA1A9652-7DE8-346A-DF56-93DA2F89A3FC}-1610427092667.png)

#### 2.3.2 与HTTP对比（没提）

HTTP和SMTP都是用TCP协议；持续的HTTP和SMTP都是用持续连接；但是两者也有区别。

- 首先HTTP被设计为一个Pull协议而SMTP被设计为一个Push协议。即用户通过HTTP主动向服务器请求内容，而SMTP则是客户将内容推向服务器端；
- 第二个区别就是HTTP传输的数据不一定是用ASCII字符，但是SMTP则只能使用ASCII字符；
- 第三个重要区别就是，HTTP将每个对象封装在自己的响应报文里，而SMTP则将所有的报文对象放到一个报文之中；

#### 2.3.4 邮件访问协议

![img](D:\software\Typora\iamge\20190324194858455.png)

需要注意的是，**SMTP是邮件服务器之间发送邮件报文**的协议，并不是用户通过代理和邮件服务器之间通信的协议；用户代理使用邮件访问协议来从邮件服务器上获取邮件信息；目前常用的邮件访问协议有**2.33**第三版邮局协议（Post Office Protocol-Version 3）、**因特网邮件访问协议**（**IMAP**，Internet Mail Access protocol）和**HTTP**

- 2.33（认证\授权\下载）

2.33简单，功能有限；2.33使用端口**110**来建立TCP连接（SMTP使用端口25）；2.33按照三个阶段进行工作：**特许、事务处理和更新**；在特许阶段，用户代理发送密码和用户名，进行身份鉴别；第二阶段，用户代理取回报文，同时还可以做删除、取消删除等标记或者统计邮件信息；第三个阶段是在用户退出后，2.33结束会话，删除被标记的邮件；

- IMAP

IMAP是一个邮件访问协议，比2.33要复杂的多，当然也就有更多的特色了。

（远程）IMAP将每一份邮件和一个一个文件夹联系起来。收件人可以将邮件移到新创建的文件夹，阅读邮件，删除邮件等。IMAP允许用户在不同文件夹里移动邮件并且查询邮件

- 基于Web的电子邮件

这种方式主要是指，用户使用HTTP协议和邮件服务器通信。用户代理就是普通的浏览器，但是，邮件服务器之间还是使用SMTP协议的。

### ※2.4 DNS：因特网的目录服务（与其他结合的考法如DNS访问顺序）

#### 2.4.1 DNS提供的服务

**DNS（Domain Name System）域名系统**。DNS是一个由**分层的DNS服务器**组成的分布式数据库和一个使得主机可以查询分布式数据库的**应用层协议**组成；

用户主机上应该运行着DNS客户端。DNS通常被其他应用层协议使用，比如：HTTP、SMTP和FTP等。这些协议在正式工作以前，首先利用DNS提供的服务，将主机名转换为IP地址

**DNS运行在UDP之上**

- 除了提供**主机名到IP地址的转换**外，DNS还提供以下重要服务：

  **主机别名**：DNS不但提供主机名到IP地址的转换服务，还提供主机名与主机别名的转换；此时主机名被称为规范主机名；
  **邮件服务器别名**：DNS同样也提供邮件服务器主机名和别名的转换服务。
  **负载分配**：DNS也被用在冗余的服务器之间分配负载。每个服务器有着不同的IP地址，但是它们都和同一个主机名相关联，也就是一个IP地址集合同一个规范主机名相联系；当某个DNS服务器收到DNS请求时，该服务器使用IP地址的整个集合作为相应，但是在每个应答中，循环这些地址的次序。因为客户端通常都是使用IP地址集合的首个元素，所以DNS就在冗余的Web服务器之间分配了负载。同理，多个邮件服务器可以具有相同的别名。？

#### 2.4.2 DNS工作机理概述（黑盒子）

集中式DNS：单点故障、流量问题、距离问题、维护困难

**DNS采用分布式的设计方案**，实际上，DNS是一个在因特网实现分布式数据库的精彩范例

- 分布式层次的数据库

  举例说明，其工作的普遍流程：一个DNS客户端，希望获得www.baidu.com的IP地址，粗略的说，DNS客户端首先和根DNS服务器取得联系，它将返回负责解析顶级域名com的服务器的IP地址（或者其集合），客户将同这些服务器之一取得联系，然后顶级域DNS服务器建返回baidu.com的权威服务器的IP集合，客户端通过与这些服务器之一取得联系，获得www.baidu.com的IP地址。

- ![image-20210112131519414](D:\software\Typora\iamge\image-20210112131519414.png)

层次结构：

**根**DNS服务器:因特网上有13个根DNS服务器，大部分分布在北美洲，尽管我们可以将这13个根DNS服务器视为单个的服务器，但是每台服务器实际上是一个冗余的计算机网络以提供安全性和可靠性；

**顶级域**DNS服务器(TLD)：负责顶级域名，如com，org，net，edu，gov以及各个国家的顶级域名的转换

**权威**DNS服务器(Aythoritative)：组织的域名解析服务

不在层次结构：

**本地DNS服务器**：本地DNS服务器通常邻近其所在网络的其他主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将请求转发到DNS服务器层次结构中。

#### DNS查询:

一种是**递归查询**一种是**迭代查询**；实践中，查询通常满足这样的模式：**从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的**。

所谓递归就是，如果请求的接收者不知道所请求的内容，那么接收者将扮演请求者，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。也就是说，在递归查询中，一定要给请求者想要的答案；

迭代查询则是指，如果接收者没有请求者所需要的准确内容，接收者将告诉请求者，如何去获得，但是自己并不去发出请求。

![img](D:\software\Typora\iamge\20190324200510122.png)![img](D:\software\Typora\iamge\20190324200527925.png)

- DNS缓存

DDNS缓存原理十分简单，每当DNS服务器发出请求后收到回答时，就将回答的内容缓存在它自己的主机空间上。因为有了缓存，本地DNS就可以直接提供一些经常被访问的主机名所对应的IP地址（一般缓存顶级域名服务器的映射），而不需要询问根DNS服务器了。如果缓存过时而未得到更新，那么就会导致一些请求失败。

### ※2.6 P2P应用（既是服务器又是客户端）

有两种典型因特网应用十分适合P2P体系结构，一种是**文件分发（BitTorrent)**，另一种是**大型对等方社区中的数据库**；我们将探讨**分布式散列表**的概念。P2P体系结构有着良好的**自扩展性**。这种扩展性的直接成因是：对等方除了比特的消费者之外还是他们的重新分发者

（32:54)

## ※第四层：运输层

传输层位于应用层和网络层之间，是分层的网络体系结构中重要的部分

该层为运行在不同主机上的**应用进程**提供直接的通信服务(**逻辑通信机制**)

![image-20210110000553140](D:\software\Typora\iamge\image-20210110000553140.png)

###  3.1 概述和运输层服务

传输层协议为运行在不同端系统上的应用进程之间提供**逻辑通信**功能；应用层进程使用传输层提供的逻辑通信功能而无需考虑实现通信的物理基础设施的细节；

值得注意的是，**传输层协议是在端系统中实现**的而不是在路由器中实现的。

传输层接收来自应用层的报文并通过添加传输层首部以生成传输层报文段。在生成过程中可能会对来自应用层的报文加以分割；然后在发送端系统中，运输层会将这些报文段交给网络层；网络层将其封装成网络层分组，也被称为数据报，然后向目的地发送**。路由器不会检查封装在数据报中的传输层报文段的字段**；在接收端，网络层从数据报中抽取传输层报文段，并将其交给传输层，传输层接收到报文段后，使该报文段中的数据被接收进程所使用。

网络应用可以使用多种传输层协议**，因特网有两种传输层协议，即TCP和UDP**，不同的传输层协议提供不同的运输层服务

### ✳TCP\UDP区别、联系、例子

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付
 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
 5、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道



- 这些应用程序使用了**TCP**作为其传输层协议：

  电子邮件、远程终端访问、Web、文件传输；

- 这些应用通常使用**UDP**作为其传输层协议：

  远程文件服务器、网络管理（因为这里应用即便在网络处于拥塞的情况下仍要工作，所以UDP更为合适）、**路由选择协议**和**名称转换**（DNS）；

- 这些应用两个都有使用：

  流式多媒体、因特网电话等多媒体应用；**这些应用对实时性的要求较高同时对可靠性的要求又不是很高，所以既可以使用UDP也可以使用TCP协议。**

| 应用                                 | 应用层协议 | 运输层协议 |
| :----------------------------------- | ---------- | ---------- |
| 电子邮件                             | SMTP       | TCP        |
| Web                                  | HTTP       | TCP        |
| 文件传输                             | FTP        | TCP        |
| 远程终端访问(remote terminal access) | Telnet     | TCP        |
| 流式多媒体                           | HTTP       | UDP/TCP    |
| 网络电话                             | SIP/RTP    | UDP/TCP    |
| 网络管理                             | SNMP       | UDP        |
| 路由选择协议                         | RIP        | UDP        |
| 名字转换                             | DNS        | UDP        |


#### 传输层和网络层的关系

1. 网络层：提供主机之间的逻辑通信
2. 传输层为运行在不同主机上的应用进程提供逻辑通信；
   - 运输层协议只工作在端系统中。
   - 运输层位于网络层之上，依赖于网络层服务。

（网络层不可靠: ）

运输层协议能提供的服务常常受制于底层网络层协议的服务类型，如果网络层协议无法为主机之间的通信提供时延和带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或者带宽保证.

然而即使底层网络协议不能在网络层提供响应的服务，运输层协议也能提供某些服务。例如，即使底层网络协议是不可靠的，运输协议也能为应用程序提供可抗的数据传输服务。）

#### 因特网传输概述

因特网为应用层提供了截然不同的两种传输层协议：**UDP（用户数据报协议）**它提供一种**不可靠、无连接**的服务；另一种是**TCP**，它提供**可靠的，面向连接**的服务；运输层分组也被称为报文段；

简单了解一下因特网的网络层:

> 网络层协议有一个名字即IP，即网际协议。IP为主机间提供逻辑通信，IP的服务模型为**尽力而为交付服务**（best-effort delivery service）这意味着IP尽最大的努力在主机间交付报文段，但是不做任何保证。它不保证报文段的交付、不保证报文段按序交付、不保证报文段中数据的完整性；即**IP提供一种不可靠的服务**；每台主机都需要有一个网络层地址，即IP地址。

UDP和TCP最基本的责任就是将IP提供的主机间交付服务扩展到不同端系统上两个个进程之间的服务。这也被称为**传输层的多路分解和多路复用**；UDP和TCP通过在传输层首部添加差错检查字段来提供完整性检查。进程到进程之间的**数据交付和差错检查**是最低限度的两种传输层服务，**也是UDP可以提供的仅有的两种服务**。UDP和IP一样，也是不可靠服务；

(TCP提供额外的服务，首先它是一种可靠数据服务，这意味着TCP协议保证数据的按序、完整地从发送端应用进程发送到接收端应用进程；TCP通过序号、确认、定时器以及流量控制来将IP的不可靠数据传输转换为可靠数据传输；其次，TCP提供拥塞控制，拥塞控制与其说是一种提供给应用程序的服务，不如说是一种提供给整个网络的服务，因为整个网络都将因为拥塞控制而受益；不太严格地说，拥塞控制力求为每一个经过一条拥塞网络的连接提供平等的共享网络链路带宽，从而避免一条TCP连接用过多的流量来淹没通信主机之间的链路和设备；拥塞控制是通过调节发送进网络的的流量速率来做得到；UDP不提供拥塞控制，使用UDP传输的应用程序可以根据需要以任意的速率发送数据。)

### 3.2 多路复用和多路分解

有前面的介绍，我们可以知道，传输层将网络层提供的面向主机的逻辑通信扩充为面向不同应用进程的逻辑通信，并且这一过程称为**多路复用和多路分解**；值得注意的是，多路复用和多路分解是每个计算机网络都需要的.

<img src="D:\software\Typora\iamge\image-20210109164214766.png" alt="image-20210109164214766" style="zoom:67%;" />

实际上，**传输层和应用程序进程之间通过Socket（套接字）**关联，这样通过Socket就可以区别同一主机上的不同应用进程，从而传输层提供服务变为可能；

传输层从同一台主机上的不同Socket**接收数据**的过程称为**多路复用**；

传输层向同一台主机上的不同Socket**传输数据**的过程称为**多路分解**；

为了实现多路复用和多路分解，我们需要标志套接字，并将相关信息添加到报文段中。

实际上，每个套接字都有一个唯一的ID，被称为**端口号**；而在传输层接收到来自应用程序的分组并通过添加传输层首部而形成报文段的过程中，该端口号被写入；端口号大小在0-65535之间，其中0-1023属于周知端口号，它们为特定的Socket而拥有。

- **无连接**的多路复用与多路分解 (UDP 二元组，目的IP 目的port)

需要注意的是，在创建Socket的时候，是由传输层为之分配端口号；一个UDP套接字是由一个目的IP地址和目的端口号即二元组来标志的；如果两个UDP报文段有不同的源IP地址或者源端口号，但是有相同的目的IP和目的端口号的话，它们将通过同一个Socket到达同一个应用程序

- **面向连接**的多路复用与多路连接（TCP 四元组）

TCP协议中的Socket是通过一个**四元组**来标记的：（源IP地址，源端口号，目的IP地址，目的端口号）；两个具有不同源IP地址或者源端口号，但有相同的目的IP地址和目的端口号的TCP报文段将通过两个不同的Socket进入同一应用进程；这也表示，一个应用进程可以关联多个Socket，而一个Socket将只关联一个应用进程；常常，这样的对应关系是通过线程来实现的：一个进程有多个线程，而每个线程关联了一个Socket；这样做可以提高服务器性能嘛

实际上，传输层就是根据这些信息来实现多路分解的；而这些信息是在多路复用的时候被放置在报文段中的

### 3.3 无连接运输：UDP

UDP只做到了**差错检查**和**数据交付(复用、分解)**这两个传输层协议必须提供的功能

（ **例子**：DNS是一个使用UDP的应用层协议例子；UDP在接收到来自Socket的数据时，UDP为该报文添加首部字段（源和目的端口号，以及其他两个小字段），然后将报文段交给网络层，网络层通过IP协议尽力地将该报文段交付，至于结果，尽力就好；当DNS客户端等待不到对该查询的响应时（有可能网络层将其丢失了）则会向其他Name Server发送查询请求，要么就通知应用程序，做不到）

**UDP有以下好处**：

-   没有拥塞控制：应用更好的控制发送时间和发送效率。
-   无需建立连接：减少时延。
-   实现简单：无需维护连接状态，减少开销
-   分组首部更小：TCP有20字节的首部开销，而UDP只有8字节；

**在UDP之上运行多媒体应用是有争议**

#### UDP报文结构

![img](D:\software\Typora\iamge\20190324210504443.png)

UDP首部只有4个字段，每个字段占用两个字节，分别是：**源端口号、目的端口号、长度和校验和**；其中，**长度表示包含首部在内的UDP报文段长度**，以字节为单位；校验和字段用来计算报文段在传输的过程中是否出现了差错；

校验和的计算：发送方将前三个字段做按位加运算，进位加到末尾然后将其取反作为校验和；然后接收方对所有四个字段（每个字段16位）进行求和，如果没有出现差错，则最后的结果全是1，否则就表明出现了错误；出现错误的原因可能有：传输链路上数据受到干扰、数据存储在中间路由器的时候，出现了错误。

![image-20210109173208035](D:\software\Typora\iamge\image-20210109173208035.png)

（UDP作为传输层协议，提供的差错检测功能很有可能和底层协议提供的相似功能产生冗余；但是，这是必须的，因为由于不能保证源和目的地之间所有链路都提供差错检测功能，即便数据在链路上正确传输，也无法保证其在中间路由器的内存中不发生错误；所以要实现端到端的差错检测，就必须在传输层协议中实现该功能；这一原则在系统设计中被称为**端到端原则**：“因为某一功能必须在端到端实现，与在较高层次提供这些功能的代价相比，在较低层次上设置的功能可能是冗余的，或者根本是没有用的”IP作为网络层协议，可以运行在任何第二层协议上，所以运输层提供差错检测也是必须的；UDP可以检测差错，但是无法恢复差错，能做的除了将其丢弃外，便是将其交给应用程序然后给出警告.）

### ※【画图】3.4可靠数据传输原理RDT(+对比)

![image-20210112165349629](D:\software\Typora\iamge\image-20210112165349629.png)

可靠数据传输对应用层、传输层、链路层都很重要

实现这种抽象服务是可靠数据传输的责任，但是因为可I靠数据传输的底层协议可能是不可靠的，所以这项任务有一点困难；

单方向的可靠数据传输流程大概是这样的：可靠数据传输->不可靠数据传输->不可靠的传输信道->可靠数据接收->上传Data

#### 3.4.1 构造可靠信道的可靠数据传输

> 一个可靠数据传输协议，将要面对以下问题：**分组丢失**、**分组损坏到达**、**分组乱序到达**
>
> 总结可靠传输需要的技术：检验和、序号、定时器、肯定和否定确认分组。

##### (1)经完全可靠信道的可靠数据传输：rdt 1.0

![img](D:\software\Typora\iamge\20190324211312185.png)

最简答的情况，底层信号完全可靠，然而这在实际中不能实现

##### (2)经具有比特差错信道的可靠数据传输：rdt 2.0

![image-20210109200647747](D:\software\Typora\iamge\image-20210109200647747.png)

假设所有发送的分组都可以按其发送顺序被接收。基于重传机制的可靠数据传输协议称为**自动重传请求协议**（ARQ）。增加了ACK和NAK

Rdt2.0引入机制：三种协议功能来处理存在比特差错的情况：**差错检测，接收方反馈，重传**。

rdt2.0的发送端每发送一个分组需要等待接收端的确认信号，这种协议被称为**停等协议**。

rdt 2.0 中有一个致命的缺陷，就是没有考虑到 ACK 和 NAK 分组受损的可能性。

##### (3) rdt 2.1

考虑ACK和NAK受损的个两可能性：

解决:发送方给每个数组增加序列号，即将发送数据分组的 **序号** 放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。对于停等协议这种简单的情况，1 比特的序号就足够了。

如果不发送NAK，而是对上次正确接收的分组发送一个ACK，我们也能实现同样的效果。

发送方接收到对一个分组的两个ACK（**冗余ACK）**后，就知道接收方没有正确接收到跟在确认两次的分组后面的分组。

![img](D:\software\Typora\iamge\20190325121428599.png)![img](D:\software\Typora\iamge\201903251215030.png)

##### (4) rdt 2.2

> rdt 2.2 是在有比特差错信道上实现的一个无NAK的可靠数据传输协议。
> 
>rdt 2.1和rdt 2.2的区别在于，接收方此时必须包括由一个ACK报文所确认的分组序号

![img](D:\software\Typora\iamge\20190325121917368.png)

![img](D:\software\Typora\iamge\20190325121939159.png)

 

##### (5)经具有比特差错的丢包信道的可靠数据传输：rdt3.0

重传：倒计数定时器，在⼀个给定的时间量过期后，可中断发送⽅。

发送⽅应做到： 

​	1）每次发送⼀个分组（包括第⼀次分组和重传分组）时，启动⼀个定时器 

​	2）响应定时器中断 

​	3）终⽌定时器

- ![img](D:\software\Typora\iamge\20190325122510710.png)
- ![img](D:\software\Typora\iamge\20190325121939159.png)

> 在 rdt 3.0 中，丢包的问题让发送方解决。不管是发送的分组丢失，还是接收方返回的确认分组丢失，只要在经过一定的时延后，让发送方重发该分组即可。
>
> 由此产生的 **冗余数据分组** 则由接收方通过序号处理。为了实现基于时间的重传机制，需要一个**倒计时定时器**
>
> 因为分组序号在 0 和 1 之间交替，因此 rdt 3.0 有时被称为 **比特交替协议**。

  ![img](D:\software\Typora\iamge\20190325122734316.png)

#### ※3.4.2 流水线可靠数据传输协议

>   rdt 3.0的核心问题在于他是一个停等协议，性能不好

- 流水线协议

> 不使用停等方式运行，允许发送方发送多个分组而无需等待确认。这种技术被称为 流水线。
> 
>**要使用流水线技术，则须：**
> 
> -   **增加序号范围**。因为要传送多个分组，而每个传输中的分组必须有一个单独的序号。
>-   协议的发送方和接收方两端必须能**缓存多个分组**。发送方至少得能缓存那些已发送但未确认的分组，而接收方或许也需要缓存那些已经正确接收的分组。
> -   所需序号的范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。
> 
**流水线的差错恢复有两种基本方法**：

- ​    回退 N 步
- ​    选择重传
> 

 

#### ※3.4.3 回退N步(GBN)：发送方

定义：  在回退N步中，发送方维护一个**N——窗口大小**和一个**base——发送方期待收到的最小待确认分组序号**，同样也是窗口的起点，还有一个**next Sequence**变量，表示上层需要发送分组时，可以使用的序号。这样全部序号就被划分为**0-base-1**，这一部分的分组是已发送且收到接收方确认的分组，**base~next Sequence-1**这一部分的分组是已发送但是尚未收到确认的，其中base是尚未收到确认的最小序号；**next-1~base+N-1**表示当前发送方可以使用的序号，表示一种发送能力；当发送方收到确认号为base的确认分组后就会向前移动窗口，所以回退N步也被称为**滑动窗口协议**

这是发送方需要维护的数据，同时发送方需要响应的事件有：**上层调用、收到ACK、超时事件**；

-   上层调用：检查next Sequence是否在窗口之内，如果在，这说明发送方还有发送能力，发送之；
-   ACK(n)：回退N步策略对序号为n的分组采取**累积确认**的方式，即当收到序号为n的ACK时，表明序号小于等于n的分组全部到位；发送方收到的ACK毕竟来自接收方，收到ACK的情况还得看接收方如何发送；
-   超时事件：如果发生超时事件，那么发送方会重发所有已发送但是未确认的分组，即分组号在base和next sequence-1之间的所有分组；这也是为什么叫“回退N步”。

在接收方，如果到达分组的序号为n且该分组是按序到达，那么发送ACK，这就导致发送方移动窗口；

如果不是按序到达，那么接收方丢弃所有失序分组；丢弃一个正确接收的失序分组可能会导致更多的重传

![img](D:\software\Typora\iamge\20190325124012709.png)

 ![img](D:\software\Typora\iamge\20190325124059136.png)

#### 3.4.4 选择重传（SR）

GBN问题：当窗口和带宽的时延都较大时，单个分组的差错可能会引起GBN重传大量的分组，然后许多本来不用重传的分组会充斥在信道中，造成资源浪费；

SR：接收方将确认一个正确接收的分组而不管其是否按序；失序的分组被缓存，直到形成连续数据后将其提交给上层；只重传没收到CK的分组

  ![img](D:\software\Typora\iamge\20190325124119196.png)

(发送方接收方窗口不同步)

**SR 发送方的事件和动作：**

-   从上层接收数据： 检查下一个可用于该分组的序号，若在发送方的窗口内，则将数据打包发送。
-   超时： 定时器再次用来防止丢失分组。但是现在每个分组必须得有单独的定时器。
-   收到 ACK：倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，（窗口移动）则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且该序号落在窗口内的未发送分组，则发送这些分组。

**SR 接收方的事件于动作：**

-   序号在 [rcv_base, rcv_base + N -1] 内的分组被正确接收：在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组及以前缓存的序号连续的分组交付给上层。（滑动窗口）
-   序号在 [rcv_base - N, rcv_base - 1] 内的分组被正确接收： 产生一个 ACK，即使该分组是接收方以前已确认过的分组。因为视图不一致
-   其他情况：忽略该分组。

值得注意的是，如果接收方收到了已经确认的分组，则说明确认ACK丢失，或者时延太长，接收方和发送方沟通不及时；这也表明了关于那些分组到位了，那些分组还没到位，接收方和发送方有着不一样的视图。

另外还需要注意的是，序号的重用问题，如果在分组中序号字段的位数为k，那么最大的序号为2^k-1，所以有可能不同分组同时占用一个序号，为了避免这种情况，需要做的是控制分组的生命周期。窗口长度必须小于或等于序号空间大小的一半。

  ![img](D:\software\Typora\iamge\20190325124151933.png)

**可靠数据传输机制和用途总结：**

![img](D:\software\Typora\iamge\201903251243005.png)

### 3.5 面向连接的TCP

> nmap:如果目的主机该端口正在ing ,返回一个特殊报文段。RST置位

 

#### 3.5.1 TCP连接

TCP协议之所以被称为是**面向连接**的协议

![image-20210110004307765](D:\software\Typora\iamge\image-20210110004307765.png)

TCP提供**全双工服务**，并且是**点对点**的，数据从A到B的同时，也能从B到A；TCP协议**无法提供“多播**”服务，一条TCP连接只关联一个发送方和接收方（当然，发送方也是接收方）；

对于TCP建立过程中的“握手”阶段，需要明白的是，手一**共握了三次**，前两次报文段不承载“**有效负载”**，第三次握手的时候，报文段是可以装载“有效负载”的；

TCP每次可以从缓存中发送的最大数据长度称为**MSS**(Maximum Segment Size)。TCP/IP的首部通常为40字节，所以MSS一般来说为1460字节。

**注意**：MSS指的是报文段中应用层数据最大长度，而不是包括TCP首部的报文段长度。

**TCP连接的每一端都有发送和接收缓存**



####  3.5.3 往返时间的估计与超时

**Sample RTT**就是从某报文段发出到收到对该报文段的确认之间的时间量。

**Estimated RTT=(1-a)*Estimated RTT+a\*SampleRTT**
 a一般取1/8；这种方法也被称为**指数加权移动平均**

**DevRTT =(1-b)\*DevRTT+b\*|Sample RTT-Estimated RTT|**
**Timeout Interval=Estimated RTT+4\*Dev RTT**

当出现超时后，TimeOutInteval值将加倍。不管怎么样，一旦报文段收到并更新Estimated RTT后，TimeInteval就又用上值计算了

#### 3.5.4 可靠数据传输

TCP协议在IP协议之上，提供**可靠数据传输**，从而保证一个进程从其相关联的缓存中读取的数据和另一端进程发送的数据是一致的；TCP使用**超时重传和累计确认**技术来处理超时、丢失等情况；使用**确认、序号**等技术来保证按序到达；使用**校验和**来检验是否报文段在传输过程中是否发生了错误；

- TCP 发送方有三个与发送和重传有关的事件：
  - 从上层应用程序接收数据
  - 定时器
  - 收到 3个ACK->快速重传



![img](D:\software\Typora\iamge\20190325130803820.png)
**3.是回退N步还是选择重传**

首先，我们需要明白的是，**TCP采用了累计确**认的机制，也就说，如果接收方正确接收了某一失序到达的分组，那么接收方发送的**ACK将是对最后接收**的按序到达的分组的确认，而不是对刚刚接收的分组的确认；

对TCP提出的一种修改意见是所谓的选择确认——即接收方对失序到达的分组也会确认，当该机制和重传机制相结合使得TCP更像选择重传，于是TCP的差错恢复协议最好被分类为GBN和SR协议的混合体.

#### 3.5.5 流量控制

流量控制是一个**速度匹配**服务：TCP连接的发送方和接收方都各自维护一个缓存，因此两者的数据交换应该在一个合理的速度范围内：不让对方发生数据溢出；TCP为它的应用程序提供了这种服务：流量控制服务。

![image-20210110005854143](D:\software\Typora\iamge\image-20210110005854143.png)

TCP会将失序到达的报文段丢弃：
    在TCP首部中有一个**窗口大小**字段，TCP连接的双方通过该字段来向对方表明自己的窗口大小，即缓存空间的大小；同样，在TCP连接的两端，各自维护着相关的变量：**last Sent、last Acked**；在发送方，这两个变量之间的分组就是**已经发送但是尚未确认的分组**；而在接收方，**last Read**表示应用进程下一次读取的数据，**last Revd**表示最后纳入缓存的报文段编号，在发送方**last Sent-last Acked应该小于等于接收方的窗口大小**；在接收端A**=last Received-last Read就是已经使用的空间大小，所以窗口大小=buffer-A**；



#### 3.3.6 TCP连接管理

**1. TCP三次握手**

PS：TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。

起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。
服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。

![img](D:\software\Typora\iamge\2019032513193995.png)

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。

  PS1：SYN=1，ACK=0表示该报文段为连接请求报文。
  PS2：x为本次TCP通信的字节流的初始序号。
  TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。
该应答发送完成后便进入SYN-RCVD状态。

  PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。
  PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。
  PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。
该报文段的头部为：ACK=1，seq=x+1，ack=y+1。
，此时连接的建立完成！

**为什么连接建立需要三次握手，而不是两次握手？**

防止失效的连接请求报文段被服务端接收，从而产生错误。

若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。



**2. TCP连接的释放一共需要四步，因此称为『四次挥手』：**

![img](D:\software\Typora\iamge\20190325131928106.png)

我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。
**第一次挥手**

若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：
FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。

  PS1：FIN=1表示该报文段是一个连接释放请求。
  PS2：seq=u，u-1是A向B发送的最后一个字节的序号。

**第二次挥手**

B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：
ACK=1，seq=v，ack=u+1。

  PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。
  PS2：seq=v，v-1是B向A发送的最后一个字节的序号。
  PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。
  A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。

第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。
**第三次挥手**

当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。
**第四次挥手**

A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。



#### **3.6.1 拥塞原因与代价**

计算机网络拥塞的原因是因为网络中的分组太多，而链路带宽和路由器缓存容量都是有限的；

### 3.7 TCP拥塞控制原理

TCP所采用的方法是让每一个发送方根据其所感知的网络拥塞程度来限制其能向连接发送流量的速率；如果TCP判断网络通畅，那么它会提高发送速率，如果TCP判断网络拥塞，那么它会限制发送速率

我们知道，TCP连接的双方都维护着两个窗口，其中一个是作为发送方的窗口，也被称为**拥塞窗口**cwnd，它对发送方能向网络中发送流量的速率进行了限制，last sent-last acked<=min{cwnd,rwnd}；另一个自然是作为接收方的接收窗口。

rate<=cwnd/RTT；发送方通过调整窗口大小来对发送数据的速率加以控制

我们将TCP发送方的丢包事件定义为：要么**超时**，要么收到接收方的**3个冗余ACK**；

另外，TCP将接收方发送的ACK视为网络通畅的标志，如果ACK到达的速率较高，那么TCP的拥塞窗口就会以较高的速率扩大，如果ACK到达的速率较慢，那么TCP拥塞窗口的增加速度也会较慢；因为TCP使用ACK对拥塞窗口做出调节，所以也别称为**自计时**的；

以上为TCP拥塞控制的概述，接下来就是广受赞誉的TCP拥塞控制算法，该算法包含三个主要部分：**慢启动SS、拥塞避免AIMD、快速恢复；**慢启动和拥塞控制是TCP的强制部分；两者的差异在于对收到的ACK做出反应时增加cwnd长度的方式；快速恢复是推荐部分，对于TCP发送方并非是必须的
**1.慢启动**

TCP连接在开始的时候，其cwnd常设置为一个MSS，然后在慢启动状态每收到一个ACK，cwnd就翻倍；这样的话，在慢启动阶段，发送速率是指数增加的（1,2,4,8…）

发送了超时、发生了冗余ACK以及cwnd达到ssthresh。**ssthresh是慢启动阈值的速记**；在慢启动阶段，如果发生了超时事件，那么ssthresh就被设置为当前cwnd的一半，然后将cwnd置为1；当cwnd逐步增加到ssthresh时，结束慢启动，进入拥塞避免模式。在拥塞避免模式里，TCP将更谨慎地增加cwnd；如果收到冗余ACK，那么TCP会做一次快速重传，然后进入快速恢复阶段；

**2.拥塞避免**

一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的一半，所以TCP在每个RTT中，只将cwnd增加一个1个MSS大小；也就是说在拥塞避免阶段，cwnd是线性增加的；

当出现超时时，TCP将cwnd设置为1，然后将ssthresh更新为cwnd的一半；当收到冗余ACK时，TCP将cwnd减半，然后将ssthresh置为cwnd值的一半，并且进入快速恢复状态；


**3.快速恢复**

在快速恢复阶段，对于引起TCP进入该状态的缺失报文段，每收到一个ACK，cwnd增加一个MSS；最终，当对丢失报文段的一个ACK到达时，TCP降低cwnd后进入拥塞避免状态；如果出现超时事件，快速恢复在执行如同慢启动和拥塞避免中相同动作后，进入慢启动状态.



## ※拥塞控制和流量控制的区别

1. 拥塞控制：拥塞控制是作用于网络的，这 **是一个全局性问**题。他的任务是确保子网能够承载所到达的流量，防止过多的数据注入到网络中，避免出现网络负载过大的情况；
2. 流量控制：流量控制只与特定的发送方和特定的接收方之间点到点的控制有关，它确保一个快速的发送方不会持续地以超过接收方吸收能力的速率传输数据。

## 第三层：网络层

![image-20210112164935359](D:\software\Typora\iamge\image-20210112164935359.png)

### 4.1 概述

#### 4.1.1 转发和路由选择

  **网络层核心功能：**
    **转发**将分组从路由器输入端口转移到合适的输出端口
    **路由选择**：确定分组从源到目的经过的路径 - 路由算法
    转发是路由器本地动作，路由选择是网络范围过程。比如开车从北京到上海，转发相当于在某个路口选择某一条岔路，路由选择相当于规划从北京到上海所有线路的过程
  每台路由都有一张**转发表**。路由器检查分组首部字段值，使用该值在转发表索引查询。该值指出了该分组将被转发的路由器输出链路接口。
  路由选择算法决定了插入路由器转发表中的值。路由器接收路由选择协议报文，来配置转发表。有两种算法：
    **集中式
    分布式**
  **分组交换机**：指一台通用分组交换设备，根据分组首部字段值从输入链路接口转移分组到输出链路接口。
    **链路层交换机**：基于链路层字段中的值做转发决定
    **路由器**：基于网络层字段值做转发决定

网络层：尽力而为服务

1）传统方法 （路由选择算法）

2）软件定义网络SDN （远程控制器确定并分发转发表中的值）

#### 4.2.2 数据报网络

>   每当端系统要发送分组，为分组加上目的地地址，推进网络。
>   分组从源到目的地传输，通过一系列路由器传递，每台都使用分组的目的地址转发该分组
>   每个路由器有转发表，将目的地址映射到输出链路接口，路由器将分组向该接口转发
>   目的地址（其实就是IP地址）32bit，转发表不可能对每个目的地址有一个表项，因此，路由器用分组的目的地址的前缀与表项进行匹配。
>
>   当有多个匹配时，使用**最长前缀匹配规则。**
>   数据包网络中路由器不维持连接状态信息，但是维护了**转发状态信息**。实际上每1-5分钟，路由选择算法更新一次转发表。
>
>   因为在数据包网络中的转发表能在任何时刻修改，从一个端系统到另一个端系统发送一系列分组可能在通过网络时走不同的路径，并可能无序到达

### 4.3 路由器工作原理

![img](D:\software\Typora\iamge\20190325213138373.png)
​    **路由转发平面**
​      一台路由器的输入端口、输出端口和交换结构共同实现了转发功能，并且用**硬件**实现
​    **路由控制平面**
​      路由器的控制功能（执行路由选择协议、对上线或者下线链路进行响应、管理功能），用**软件**实现并在选择处理器上执行（一种cpu）

#### 4.3.5 路由选择控制平面

  网络范围的路由选择控制平面是分布式的，即不同部分（如路由选择算法）执行在不同的路由器上，并且通过彼此发送控制报文进行交互

### ※4.4 网际协议（IP）：因特网中的转发和编址

  **网络层三个组件**

- ​    IP协议
- ​    路由选择协议
- ​    控制报文协议（ICMP）：报告数据报中的差错、对某些网络层信息请求进行响应的设施

![img](D:\software\Typora\iamge\20190325214358205.png)

-   首部检验和：帮忙路由器检测收到IP数据报中首部的比特错误，有错一般丢弃。每台路由器上必须重新计算检验和。IP层仅对IP首部计算检验和，而TCP/UDP检验和是对整个TCP/UDP报文段进行的。

    一个IP数据报有长为**20**的首部，如果数据报承载一个TCP报文段，则每个无分片数据报承载总长40的首部（还有TCP的20）以及应用层报文
    

> 网络链路存在MTU (最大传输单元)
>
> IPv4的设计者决定把数据报的重新组装工作放在端系统而不是路由器中。
>
> 大IP分组向较小MTU链路转发时， 可以被“分片” (fragmented)
>
>   1个IP分组分为多片IP分组
>   IP分片到达目的主机后进行“重组”(reassembled)
>
> 例：
>
>   4000字节的数据报，在MTU1500字节的链路上
>
> ![img](D:\software\Typora\iamge\20190326135559160.png)
> 
> 数据报的有效载荷仅当在IP层已完全重构为初始IP数据报时，才会传递给目的地传输层。如果一个或多个片没有到达目的地，则该不完整的数据报被丢失。
> 一个链路层帧承载的最大数据量：**最大传送单元MTU**

**1）如何将过大的IP分组压缩进链路层帧的有效载荷字段？**
      将IP数据报中的数据分片成多个较小的IP数据报，用单独的链路层帧封装这些小IP数据报，每个小数据报叫**片**
      IPv4将数据报的重新组装放在端系统中，而不是路由器中
  **标识、标志、片偏移字段，帮助主机执行重组任务**
    IPv6废除了分片，简化了IP分组的处理

#### 4.4.2 IPV4编址

  **主机与路由器连入网络的方法**

- ​    一台主机通常只有一条链路连接到网络，主机IP发送数据报从该链路发送

- ​    主机与物理链路的边界叫**接口**，一台路由器有多个接口

- ​    IP要求每台主机和路由器都有自己的**IP地址**，因此一个IP地址实际上是与每一个接口相关联的

  每个IP地址长度32bit（4字节），总共2^32个可能的IP地址，约40亿个

  **点分十进制记法**，如193.32.216.9

  ![image-20210112174543555](D:\software\Typora\iamge\image-20210112174543555.png)

- ​    一个接口的IP地址的一部分需要由其连接的子网决定.如互联3个主机接口与1个路由器接口的网络形成一个子网，IP编址为这个子网分配一个地址：223.1.1.0/24，/24记法称为**子网掩码**，指示了32bit中的最左侧24bit定义了**子网地址**

- ​    为了确定**子网**，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点，这些隔离的网络中每一个都叫做一个子网

  

  因特网地址分配策略：**无类别域间路由选择CDIR**

- ​    a.b.c.d/x的地址的x最高比特构成IP地址的**网络部分**，称为该地址的前缀，一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。BGP路由选择协议中，该组织网络外的路由器仅考虑x，减少了转发表的长度，因为形式为a.b.c.d/x单一表项足以将数据报转发到该组织内的任何目的地

-   在CDIR出现之前，采用**分类编址**，**A、B、C**类网络，分别具有**8、16、24**比特子网地址

- IP=NetID（网络号）+SubID（子网号）+HostID（主机号）

  子网掩码：Netid、subid=1，hostid=0；；子网地址+子网掩码确定子网大小

  E：首位1111

  D：首位1110

  C类：110（/24）仅能容纳2^8-2=254台主机（其中两个用于特殊用途）255.255.255.0

  B类：10（/16）支持65534台主机，一个组织分配一个B类地址却只用2000个接口，造成巨大浪费 255.255.0.0

  A类：0 （/8）255.0.0.0

  <img src="D:\software\Typora\iamge\image-20210112183326401.png" alt="image-20210112183326401" style="zoom:67%;" />

  **IP广播地址**
      当一台主机发出目的地址为**255.255.255.255**的数据报时，报文会交付给同一个网络的所有主机，路由器也会有选择的向邻近的子网发送报文（通常不这样做）。可用于DHCP发现报文的发送，广播最小生成树

**如何获取地址、分配地址？**
    **1. 获取一块地址**
      子网获取IP地址：由ISP从它大块地址中分配
      ISP获取IP地址：IP地址由因特网名字和编号分配机构ICANN管理（也管理DNS根服务器、AS标识号）。ICANN向区域性因特网注册机构分配地址，处理本地域内的地址分配/管理
    **2.获取主机地址**
      组织获得一块地址，就可为组织内的主机、路由器接口**逐个分配**IP地址
      主机地址能手动配置，也能自动配置，即动态主机配置协议DHCP
    **3.动态主机配置协议DHCP---UDP**
      DHCP允许主机自动获取一个IP地址
      DHCP可配置，可以使主机每次连网获得相同IP地址，也可每次分配一个临时IP地址。
      DHCP还允许主机查看子网掩码、默认网关（第一跳路由器地址）、本地DNS服务器地址
      DHCP能将主机连接进一个网络的自动能力，常被称为**即插即用协议**
      DHCP是一个**客户-服务器协议**。新来的主机要获得自使用的IP地址等网络配置信息
      **每个子网**都有一台**DHCP服务器**
       若子网没有DHCP服务器，则由一个路由器做**DHCP中继**代理，该代理知道该网络的DHCP服务器地址![image-20210112191252187](D:\software\Typora\iamge\image-20210112191252187.png)

![](D:\software\Typora\iamge\20190325222043408.png)
      **新主机到来时，DHCP协议的四个步骤**

​        **1.DHCP服务器发现**

​          新到的客户通过广播DHCP发现报文，发现一个要与其交互的DHCP服务器
​          客户在**UDP**分组中向端口67发送该发现报文，此时必须用广播地址255.255.255.255，源地址是0.0.0.0
​        **2.DHCP服务器提供**
​          DHCP收到DHCP发现报文后，响应一个DHCP提供报文，仍然使用广播地址，因为此时新客户并没有IP地址
​          可能有多台DHCP服务器，每台服务器提供的报文中，有向客户主机推荐的IP地址、网络掩码以及IP地址租用期（一般几天或几小时）
​        **3.DHCP请求**
​          客户从提供中选一个，向选中的服务器提供一个DHCP请求报文进行响应，回显配置参数
​        **4.DHCP ACK**(包括IP地址、子网掩码、DNS服务器地址)
​          收到DHCP请求报文后，用DHCP ACK报文对其记性响应，证实所传参数
​      客户收到ACK后，交互完成，在租期内使用DHCP分配的IP地址。DHCP提供了机制允许客户**更新**对一个IP地址的租用

<img src="D:\software\Typora\iamge\image-20210112191746828.png" alt="image-20210112191746828" style="zoom:80%;" />

 当一个移动结点在子网之间移动时，就不能维持与远程应用的TCP连接。
 ※**4.网络地址转换NAT**

![image-20210112193305453](D:\software\Typora\iamge\image-20210112193305453.png)

> 地址10.0.0.0/8是保留的3个IP地址空间之一，这些地址用于家庭网络等专用网络或具有专用地址的地域。具有专用地址的地域是指其地址仅对还网络中的设备有意义的网络。
>
>  当ISP已经为SOHO网络当前地址范围分配过一块连续地址，而SOHO内主机越来也多时，需要用到NAT（比如电信给你家分配一个动态IP地址，家里要好几台手机电脑联网用一个IP地址，需要用NAT）。

**NAT使能路由器**
  NAT路由器对外界来看像一个具有**单一IP地址的单一设备**。例如，家里有一个NAT使能路由器，其IP地址138.76.29.7，且进入和离开家庭的报文都有同样的该地址
  NAT路由器对外隐藏了家庭网络的细节
  NAT路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个**DHCP服务器**，为位于NAT-DHCP路由器控制的家庭网络地址空间中的主机提供地址
  **NAT转换表**：

​    ![image-20210112193421555](D:\software\Typora\iamge\image-20210112193421555.png)

   端口号和IP地址用于路由器将分组转发给特定的内部主机（比如家里的某个手机） **NAT重要问题**：
   地址短缺问题应该用IPv6来改进
   妨碍P2P应用程序，包括P2P共享和语音。一个对等方在NAT后面，不能充当服务器并接受TCP连接，其解决办法是连接反转

   ### ※NAT优点和缺点

NAT的优点：
 1. 节省大量合法的公有ip地址
 2. 地址重叠时，提供解决办法
 3. 网络发生变化时，避免重新编址
 4. 能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机

NAT的缺点：
 1. 无法进行端到端的ip跟踪（破坏了端对端通信的平等性）
 2. 很多应用层协议无法识别（比如ftp协议 ）

#### 4.4.3 因特网控制报文协议ICMP

  ICMP被主机和路由器用来沟通网络层信息，如**差错报告**
   如『目的网络不可到达』这种错误是在ICMP产生的，IP路由器找不到路径通往指定主机，该路由器就向发送主机发出ICMP报文指示错误
  ICMP通常被认为是IP的一部分，但从体系结构上来讲它是位于IP之上的，因为ICMP报文是承载在IP分组中的。也就是说，ICMP报文是作为IP有效载荷承载的。
  **Traceroute：如何跟踪从一台主机到世界上任意一台主机之间的路由？**

   方法：发送TTL为1~n的一系列IP数据报。当到达目的主机时，返回一个端口不可达（数据报携带了不可达UDP端口号）的ICMP报文，则结束探测

#### 4.4.4 IPv6

![img](D:\software\Typora\iamge\20190325225015136.png)

 **动机**： 32位IPv4地址耗尽，改进IPv4首部格式
  I**Pv6数据报格式（不一样的地方）**

- ​    扩大的地址容量

​      32bit —> 128bit
​      除了单播多播地址，引入任播地址，使数据报交付给一组主机中的任意一个

-   固定长度的40字节首部
- ​    不允许分片
- ​    去除首部检验和


**2. IPv4到IPv6的迁移**（好处坏处）

   **建隧道：**图中B和E，要使用IPV6交互，但是它们经由中间IPv4路由器关联的，我们将两台IPv6路由器之间的Ipv4路由器的集合成为一个**隧道**，将整个IPv6数据报放在IPv4的有效载荷中。

![image-20210112195216367](D:\software\Typora\iamge\image-20210112195216367.png)

### ※4.5 路由选择算法（计算题）

  路由选择：确定从发送方到接收方通过路由器网络的好路径
  主机通常直接与一台路由器相连，该路由器即为该主机的**默认路由器**或**第一跳路由器**
    源主机默认路由器称为**源路由器**，目的主机默认路由器称为**目的路由器**
    一个分组从源主机到目的主机 == 从源路由器到目的路由器
  路由选择算法：给定一组路由器和连接路由器的链路，路由选择算法找到一条源路由器到目的路由器好的路径（最低费用），如最短路径算法
    **第一种分类方法：**

​      **全局式路由选择算法**

​        用完整、全局性的网络信息计算出最短路径（最低费用路径）
​        具有全局状态信息的算法称作链路状态算法（LS）
​      **分散式路由选择算法**
​        迭代、分布式的方式计算最短路径
​        没有结点拥有关于网络链路的完整信息，每个结点仅有与其直接相连链路的信息即可工作
​        通过迭代计算并与相邻结点交换信息，逐渐计算出最低费用路径，距离向量算法（DV）
​    **第二种分类方法：**
​      **静态路由选择算法**
​        变化缓慢，通常人工干预
​      **动态路由选择算法**
​        网络流量负载或拓扑发生变化时改变路由选择路径
​        周期性运行或直接响应变化
​        也容易受路由选择循环、路由震荡等问题的影响
​    **第三种分类方法**：
​      **负载敏感算法**
​        链路费用动态变化来反映链路拥塞水平
​      **负载迟钝算法**
​        链路费用与拥塞无关，**当今因特网路由选择算法基本都是迟钝的**

#### 4.5.1 链路状态路由选择算法LS

  网络拓扑和所有链路费用已知。实践中是由每个节点向网络其他所有节点广播链路状态分组完成的，例如**OSPF**路由选择协议由链，路状态广播算法完成
  所有节点都具有该网络的信息，每个节点运行LS算法
  **Dijkstra算法**
  会产生路由震荡，可以让每台路由器发送链路通告的时间随机化

#### 4.5.2 距离向量路由算法DV

  **迭代、异步、分布式**
    分布式：**每个结点要从一个或多个直接相连邻居接收某些信息**，计算，将计算结果发给邻居
    迭代：过程持续到邻居之间无更多信息交换
    异步：不要求所有节点相互步伐一致操作
  **DV算法**
    Bellman-Ford方程
    无更新报文发送，不会出现进一步路由选择表计算，算法进入静止状态。直到一条链路费用发生改变
  链路费用改变与链路故障
  **路由选择环路，无穷计数问题**
  **增加毒性逆转**
    欺骗费用无穷大。如果z通过y路由选择到目的地x，则z通告y，它（z）到x的距离是无限大。
    解决两个直接相连无穷计数问题，更多结点环路无法解决
  **LS与DV路由选择算法的比较**
    报文复杂性
      显然LS复杂得多，每条链路费用改变都要通知所有结点
    收敛速度
      DV算法收敛较慢，且会遇到路由选择环路和无穷计数问题
    健壮性
      路由器发生故障，LS结点仅计算自己的转发表，提供了一定健壮性
      DV算法一个 不正确的结点会扩散到整个网络

#### 4.5.3 层次路由选择自治系统AS

  **问题**
    规模。当路由器数目变得很大，算法开销高的不可实现如LS更新链路费用
    **管理自治**。一个组织应该当按自己愿望运行管理其网络
  **解决方法：将路由器组织进自治系统AS**
    每个AS由一组处在相同管理控制下的路由器组成（如相同的ISP运营）
    相同AS中路由器全部运行同样的路由选择算法，叫做**自治系统内部路由选择协议**intra-ASrooter
    一个AS内一台或多台路由器负责向本AS之外的目的地转发分组，这些路由器称为**网关路由器inter-AS**当有多台网关路由器，需要用到自制系统间路由选择协议来配置转发表

​    每台路由器接收来自一个AS内部路由选择协议和一个AS间路由选择协议的信息，并使用来自这两个协议的信息配置它的转发表。
  **某AS非网关路由器对转发表增加用于子网x（该AS外）的表项采取的动作：**
​    从AS间协议知道经多个网关可达子网x
​    使用AS内部协议的路由选择信息，决定到每个网关的最低费用路径的费用
​    AS间**热土豆路由选择**：选择具有最小的最低费用的网关
​    从转发表确定最低费用网关接口I，将（x,I）添加到转发表中
  如果AS从一个相邻AS处知道一个目的地，该AS能向它某些其他相邻AS通告该路由选择信息
  一个ISP可能分为多个互联的AS

### 4.6 因特网中的路由选择

  AS内部路由选择协议，又称内部网关协议
    路由选择信息协议**RIP**，通常设置在下层ISP中
    开放最短路径优先**OSPF**，通常设置在上层ISP中

#### 4.6.2 AS内部的路由选择：OSPF（LS思想）

开放的  兄弟协议IS-IS

OSPF核心：使用洪泛链路状态信息的**LS**协议 + **Dijkstra最低费用路径算法**。**各条链路费用（权值）是管理员配置的**
  使用OSPF，一台路由器构建了整个AS的拓扑图，然后在本地运行Dijkstra算法
  使用OSPF，路由器向AS内所有其他路由器**广播路由选择信息**。即使链路未发生变化，也要周期性广播链路状态（at least 30 minutes at a time）

  OSPF报文由**IP**直接承载
  优点：
    **安全**
    **多条相同费用路径**：无需仅选择单一路径承载所有流量
    **支持单播多播路由选择**
    **支持在单个路由选择域内的层次结构**：具有按层次结构构造一个自治系统的能力
  一个OSPF AS可以配置成多个区域，**分层**
    一个区域内，一台或多台**区域边界路由器**负责为流向该区域以外的分组提供路由选择
    AS内只有一个OSPF区域配置成主干区域，为其他区域之间的流量提供路由选择。该主干包含AS内所有区域边界路由器，也可能包含一些非边界路由器
    某区域内分组—》区域边界路由器—》主干—》目的区域边界路由器—》目的地

![image-20210112205851479](D:\software\Typora\iamge\image-20210112205851479.png)![image-20210112205911521](D:\software\Typora\iamge\image-20210112205911521.png)

![image-20210112205923855](D:\software\Typora\iamge\image-20210112205923855.png)![image-20210112205935951](D:\software\Typora\iamge\image-20210112205935951.png)

<img src="D:\software\Typora\iamge\image-20210112205956028.png" alt="image-20210112205956028" style="zoom:67%;" />

#### 4.6.3 AS间的路由选择：BGP

>   BGP：**边界网关协议**，跨越多个AS的源和目的对之间确定路径，现在用的BGP4
>   **BGP为AS提供：**
>     eBGP从相邻AS获得子网可达性信息
>     iBGP向本AS内部所有路由器传播这些可达性信息
>     基于可达性信息和AS策略，决定到达子网的路由
>   BGP使得每个子网向因特网其余部分通告它的存在：一个子网高声宣布『在这！』，并且确保因特网中所有AS知道该子网以及如何到达
>   **1. BGP基础**
>     是因特网中至关重要的协议，正是BGP将一切『粘合』起来
>     BGP中，路由器通过TCP连接来交换路由信息
>       跨越两个 AS的TCP连接称为**外部BGP会话eBGP**，AS内部每对路由器之间的TCP连接成为**内部BGP会话iBGP**
>       iBGP并不总与物理链路对应
>    
>   <img src="D:\software\Typora\iamge\image-20210112210329355.png" alt="image-20210112210329355" style="zoom:67%;" /> 
>   
>   **AS-PATH：**该属性包含了前缀通告已经通过的AS，当一个前缀传送到一个AS时，AS将其ASN增加到AS-PATH中
>      路由器使用AS-PATH属性检测和**防止循环通告**
>     **NEXT-HOP：**是一个开始某AS-PATH的路由器接口
>    **BGP路由选择**
>     BGP使用eBGP和iBGP向在AS中的所有路由器发布路由，路由器可能知道到达任何一条前缀的多条路由。消除规则从上到下：
>    
>    - ​      选择具有最高本地偏好值（管理员决定）的路由
>    - ​      选择具有最短AS-PATH的路由
>   - ​      最靠近NEXT-HOP路由器的路由，最靠近指最低费用路径最低，由AS内部算法决定（hot potato routing）
>    - ​      使用BGP标识符选择路由
>



## 第二层：链路层

​    **链路层是协议栈中软件和硬件交接的地方**

### ※重点：链路层作用、差错编码、多路访问协议、Lans 、Mac地址、web应用

### 5.1.链路层概述

  运行链路层协议的任何设备均称为**结点**，沿着通信路径连接相邻结点的通信信道称为**链路**。通过特定链路时，传输结点将数据报封装在链路层帧中，将该**帧**传入链路
  举例：游客想从苏州到临汾玩，旅行社安排的线路是：第一段线路是从苏州乘火车到上海，第二段线路是在上海坐飞机到太原，第三段线路是太原坐大巴到临汾
    游客相当于数据报
    每个运输段相当于一条链路
    每种运输方式相当于一种链路层协议
    旅行社相当于一个路由选择协议

**能够提供的协议可能包括：（不同协议包括不同，细节不同）**
    **成帧**
      网络层数据报经链路传送前，链路层协议要将其用链路层帧封装起来
      帧的结构由链路层协议规定
    **链路接入**
      **媒体访问控制MAC协议**，规定帧在链路上传输的规则，协调多个结点的帧传输
    **可靠交付**
      保证无差错经链路层移动每个网络层数据报
      **确认和重传**，类似TCP
      通常用于高差错率链路，如无线链路，同轴电缆、光纤、双绞线等链路不需要
      目的是在差错发生的链路上纠正差错，而不是通过运输层或应用层进行端到端数据重传

​      链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因，许多有线的链路层协议不提供可靠交付服务。
​    **差错检测和纠正（硬件）**
​      奇偶校验
​      检验和
​      循环冗余检测

### ※1.差错编码

#### 差错编码基本原理：

在数据基础上，增加一些冗余信息；

这些冗余信息，建立了数据位和 位之间、比特之间 原本不存在的一个关联关系；

发送端将冗余信息和数据发送给目的地，接收端确认该关联关系是否存在。

 

![img](D:\software\Typora\iamge\1397445-20180628133814147-320387852.png)

 R：冗余比特，又称监督位

**将R附着在D上，利用发送端生成R的算法，去计算接收到的D，将计算得到的R去跟接收到的R匹配**

**相同则没错，不同则丢弃。**

注意，差错编码不能保证100%可靠！

------

#### 差错编码的检错能力

**检错码**：只能检错

**纠错码**：既能检错，还能纠错

汉明距离：两个码之间对应比特位不同的位数

编码集的汉明距离：编码集内所有有效码，任意两个码之间汉明距离的最小值

 1、对于检错码，如果编码集的汉明距离![img](D:\software\Typora\iamge\1397445-20180628144944374-1519037264.png)，则该差错编码可以检测r位的差错

![img](D:\software\Typora\iamge\1397445-20180628145521619-950359287.png)

![img](D:\software\Typora\iamge\1397445-20180628145725534-1605443159.png)

 2、对于纠错码，如果汉明距离![img](D:\software\Typora\iamge\1397445-20180628145258384-705030087.png)，则该差错编码可以纠正r位的差错

![img](D:\software\Typora\iamge\1397445-20180628145529127-2091288956.png)

![img](D:\software\Typora\iamge\1397445-20180628145729946-1425438678.png)

------

#### 常见的差错编码

1、奇偶校验码 

![img](D:\software\Typora\iamge\1397445-20180628145906983-299942678.png)

 （1bit 50% 准确率，效率高，只能检测奇数错误）（奇校验 奇数个1 偶校验 偶数个1）

2、internet校验和 checksum

![img](D:\software\Typora\iamge\1397445-20180628150107260-2143531392.png)

------

#### 校验和方法：

在校验和方法中,数据被切成k比特的序列,这些序列全部相加之后取反码就是校验和.接收方收到数据之后,把所有数据加起来(包括校验和).用结果是否全为1来作为判断数据是否出错的标准.

和CRC相比,校验和提供较弱的保护.
为什么传输层使用校验和而链路层使用CRC呢?

1. 传输层使用软件实现,采用简单快速的方案是必须的(校验和)
2. 链路层的CRC用硬件实现,能够快速执行CRC操作.

#### CRC，循环冗余校验码

检错能力更强大的差错编码

1、将数据比特，**D**，视为一个二进制数，

2、选择一个**r+1**位的比特模式（生成比特模式），**G**

3、选择一个**r**位的CRC比特，**R**

4、<D，R>刚好可以被G整除（模2）

5、**接收端检错，利用G除<D，R>，余全0，无错，否则有错**

6、可检测所有突发长度小于r+1位差错

**实现：**

![img](D:\software\Typora\iamge\1397445-20180628140310258-1105450204.png)

（广泛应用于实际网络 ethernet，wifi，atm）D左移r位

![img](D:\software\Typora\iamge\1397445-20180628140316064-303366117.png)

**XOR亦或，余式就是我们要求的R**

**发送端：一个就是左移运算，再加另外一个亦或运算**

**注意，**

**只要G（r+1）确定了，r确定了，R也确定了，不管数据比特D是多大，**

**当数据比特D很大，R就比较小**

**由于CRC编码计算非常简单，因此很容易利用硬件去实现，**

**所以很多链路层，直接用网卡做这个事情。**

 ![img](D:\software\Typora\iamge\1397445-20180629182347244-590218529.png)

由图可知，R即3位循环冗余位

D左移三位，(除法是异或运算)

G位3+1=4位模式（用来生成多项式）

 <img src="D:\software\Typora\iamge\1397445-20180629182517129-1622811003.png" alt="img" style="zoom: 50%;" />

**广泛应用于实际网络**

比如以太网、802.11、wifi、ATM

---

### 5.2 多路访问控制MAC协议：规定帧在链路上传输的规则，协调多个结点的帧传输

#### **两类“链路”**

**![img](D:\software\Typora\iamge\1397445-20180628141412976-1667937504.png)** 

#### **解决的场景**

单一共享广播信道——>> 假如有两个或两个以上的结点在该共享介质上同时传输，会产生**干扰**的问题interference

![img](D:\software\Typora\iamge\1397445-20180628142351713-1665512365.png)

\- 为了协调共享链路的使用，引入**多路访问控制协议MAC**，采用分布式算法决定结点如何共享信道，即**决策结点何时可以传输数据**

\- 必须基于信道本身，通信信道共享协调信息

#### **理想的MAC协议**

给定：速率为 R bps的广播信道

期望：

![img](D:\software\Typora\iamge\1397445-20180628142540669-1414230689.png) 

#### **MAC协议分类**

<img src="D:\software\Typora\iamge\1397445-20180628142957431-1866878726.png" alt="img" />

<img src="D:\software\Typora\iamge\image-20210109135308564.png" alt="image-20210109135308564" style="zoom: 50%;" />

##### 信道划分协议

![img](D:\software\Typora\iamge\20190326130509228.png)

**TDM(时分多路复用)**

  TDM把时间划分为时间帧,并进一步把时间帧划分为N个时隙(slot).(时间帧和链路层交换的单元帧不是一个意思)
然后把每个时隙分给N个节点中的一个.无论何时某个节点在有分组想要发送的时候,他在循环的TDM帧中指派给它的时隙内传输分组比特.时隙长度一般应是一个时隙内能传输一个分组

**TDM的缺点**
​     1. 最高速率只能达到R/N bps ,即使只有一个人使用信道
​     2. 节点总是总是要等待它的时隙,可能会对缓存等造成压力
     3.消除了碰撞且十分公平
**FDM(频分多路复用)**

  FDM将Rbps的信道划分为不同的频段(每个频段具有R/N带宽),并把每个频段分给N个结点中的一个.因此FDM在N个较大的信道中创建了N个较小的R/N信道.

  FDM的缺点和TDM相同,限制了每个结点只能使用R/N带宽..
 **码分多址CDMA**
      TDM和FDM分别为结点分配时隙和频率，CDMA对每个结点分配不同的编码
      每个结点用其唯一编码对发送数据进行编码，使得不同结点能同时传输，接收方仍能正确而接收
      抗干扰，军用系统，民用蜂窝电话

#####     轮流协议

​      **轮询协议**
​        指定一个主结点，以循环的方式轮询每个结点
​        主结点首先向结点A发送一个报文，告知A能传输帧的最大数量，A传完后主结点告诉B能传帧的最多数量，如此循环
​        缺点：有轮询时延；主结点故障，整个信道就GG
​      **令牌传递协议**
​        没有主结点，一个叫令牌token的特殊帧在结点之间以固定次序交换，如1发给2，2发给3，N发给1，就像网络拓扑结构中的环状网络令牌
​        当一个结点收到令牌时，有帧发送，则发送最大数量的帧，然后转发令牌；没帧发送，直接把令牌转发.

​        缺点：单点故障。
   5.4 交换局域网

  交换机运行在链路层，它们使用**链路层地址**而不是IP地址来转发链路层帧通过交换机网络
### 5.3 LANS 局域网
####   链路层寻址和ARP

​    **1.MAC地址**
​      MAC地址（Media Access Control Address），直译为媒体访问控制地址，也称物理地址（Physical Address）
​      并不是**主机或路由器**具有链路层地址，而是它们的适配器（网络接口）具有链路层地址。具有多个网络接口的主机或路由器也有多个链路层地址，就像它也有多个IP地址一样。
​      链路层交换机并没有链路层地址，交换机透明地执行在主机与路由器之间承载数据报的任务。
​      链路层地址也叫**LAN地址、物理地址、MAC地址**
​      MAC地址长度**6字节,48位**，通常用**十六进制表示法**，如5C-66-AB-90-75-B1
​      MAC地址一般是固定的（也有软件改变适配器MAC地址的可能）
​      **每一个网卡有唯一的MAC地址，没有两块适配器有相同的MAC地址**，MAC地址空间由IEEE管理，IEEE给公司固定前24个比特，后面U24个比特让公司自己去生成
​      MAC地址具有**扁平接口**。比如具有802.11接口的手机总是有相同mac地址，而当主机移动时，IP地址会改变，依赖于子网（IP地址是**层次结构**）
​      MAC地址像身份证号，IP地址像邮政地址，有层次，会改变
​      当某适配器要向目的适配器发送一个帧时，发送适配器将目的适配器的MAC地址插入该帧，发送到局域网上，适配器可以接受一个并非向它寻址的帧，当适配器接受一个帧时，检查帧中的目的MAC地址与自己的MAC地址是否匹配，若匹配则取出数据报，向上传递，否则丢弃
​      适配器通过**MAC广播地址FF-FF-FF-FF-FF-FF**来广播

  **2. 地址解析协议ARP（即插即用的）**

<img src="D:\software\Typora\iamge\image-20210109150202350.png" alt="image-20210109150202350" style="zoom:50%;" />

​      转换网络层地址和链路层地址，如**IP地址和MAC地址的转换**
​      DNS为因特网中任何地方的主机解析主机名，而ARP只为在同一个**子网**上的主机和路由器接口解析IP地址
​      每台主机和路由器在内存中有一个**ARP表**，包含IP地址到MAC地址的映射关系，过期时间20分钟
​      若发送方的ARP表没有目的主机的表项，发送反公用ARP协议来解析这个地址
​        首先发送方构造一个ARP分组，字段包括发送和接受IP地址和MAC地址，ARP查询分组和响应分组格式相同
​        适配器用MAC广播地址发送该ARP查询分组，每个适配器都把ARP分组向上传递给ARP模块，检查自己的IP地址和分组中的目的IP地址是否一致
​        匹配的主机发送回一个ARP响应分组，然后查询主机更新它的ARP表，并发送它的IP数据报
​      ARP协议是一个跨越链路层和网络层的协议
​    **3. 发送数据报到（局域网）子网以外**
​      路由器有几个接口，就有几个IP地址、ARP模块和适配器，假设一个路由器连着两个子网A、B
​      子网A中的适配器要发往子网B中的适配器，先通过子网A的ARP把数据报发到子网A跟子网B相连的路由器的左侧接口（目的地址是路由器的MAC），路由器通过子网B的ARP将该数据报转发给目的适配器（目的地址是最终目的地的MAC）。

![image-20210109151232364](D:\software\Typora\iamge\image-20210109151232364.png)

![image-20210109151407214](D:\software\Typora\iamge\image-20210109151407214.png)

### ※IP地址与MAC地址的区别与联系

1. **IP地址32位二进制，MAC地址48位十六进制**

2. 对于网络上的某一个设备，其**IP地址是可变的（但必须是唯一的），而MAC地址不可变。**

3. IP地址的分配基于网络的拓扑结构，而MAC地址的分配基于制造商。

4. IP地址应用于网络层，而MAC地址应用在数据链路层。

   ---

     

####   以太网

​    以太网占领了现有的**有线局域网**市场，就像因特网之于全球联网的地位
​   **星形拓扑以太网**，目前主流网络拓补现在位于中心的集线器被交换机所取代。交换机是无碰撞的存储转发分组交换机，运行在链路层
  **以太网帧结构**

 ![img](D:\software\Typora\iamge\20190326133620706.png)
    数据字段（46~1500字节）：承载了IP数据报（如），超过1500字节的数据报需要分片；若小于46字节，需要填充到46字节。
    目的地址（6字节）：目的适配器的MAC地址。当目的适配器收到一个以太网帧，若目的地址是自己的MAC地址或广播地址，将数据字段传给网络层，其他则丢弃
    源地址
    类型字段：允许以太网复用多种网络层协议
    CRC（4字节）：差错检测，丢弃差错帧
    前同步码（8字节）：以太网帧以前同步码开始，前7个字节用于唤醒接收适配器，**同步发送方接收方时钟**，第8个字节最后两个比特（11）警告目的适配器，重要内容来了
    以太网技术向网络层提供**不可靠**、**无连接**服务。没有通过CRC校验只是丢弃。

​    以太网有时候的确重传了数据，但并不知道正在传输新数据还是旧数据。


####   链路层交换机

​    交换机的任务：接收入链路层帧，转发到出链路
​    交换机自身对子网中的主机和路由器是透明的，主机/路由器向另一个主机/路由器寻址一个帧，顺利将帧发送进局域网，并不知道交换机干嘛

​    交换机输出接口设有缓存
​    交换机是**即插即用**设备，管理员无需配置
​    交换机是**双工**的，任何交换机接口能同时发送和接收
  **转发和过滤**
​    借助于交换机表，包含局域网上某些主机和路由器的表项（MAC地址，通向该地址的交换机接口，表项放置的时间）
​    **假定目的地址为DD-DD-DD-DD-DD-DD的帧从交换机接口x到达，交换机用该MAC地址索引交换机表，有三种可能：**
​      表中没有该地址，交换机广播该帧
​      表中有表项将该地址与接口x联系起来，过滤掉，因为该帧从x来，DD也通过x去，说明该帧跟DD适配器在同一个局域网段，（不需要转发）该帧已经在包含目的地的局域网网段广播过了
​      表中有表象将该地址与接口y≠x联系起来，该帧需要被转发到与接口y相连的局域网段，放到接口y前的输出缓存，完成转发功能
  **自学习：表是自动、动态建立的**
​    交换机表初始为空
​    对于每个接口接收到的每个入帧，交换机在其表中存储
​      该帧源MAC地址
​      帧到达的接口
​      当前时间
​    一段时间后，交换机没有接受到以该地址作为源地址的帧，在表中删除该地址。如果一台PC被另一台PC代替，原来PC的MAC地址将被清除

###  ※ **交换机和路由器比较**

![img](D:\software\Typora\iamge\20190326134513562.png)
    
二者均为存储转发，二者均使用转发表
交换机：交换机是链路层设备
      交换机利用自学习，泛洪构建转发表，依据MAC地址，即插即用
      对广播风暴不提供任何保护，使得以太网崩溃
 	 是直通传输
路由器：路由器是网络层设备，
      利用路由算法设置转发表，需要人为配置IP地址，不是即插即用
      对第二层的广播风暴提供了防火墙保护

### ※5.4 **Web页面请求的历程P326**

## 写在前面

学完计算机网络的协议栈，对Web页面请求的完成历程做一次总结。想象一下，当我们在浏览器上输入一个URL地址，到页面呈现出来的过程中，网络上都发生了什么？这个过程绝对很有趣。

现在假设我在校园网内，通过**有线接入**校园网的一台交换机，开始我的冲浪之旅。下面我将描述自己在冲浪过程中的发现。其中，交换机连接了学校的对外的出口路由器。假设DHCP服务器运行在路由器中。网络拓扑如下：

------

## 准备：DHCP、UDP、IP和以太网

首先，为了上网，我必须告诉网络我是谁，只有网络知道我是谁，它才会允许我进入它的家门。所以，我的笔记本首先需要一个**IP地址**。

1） 如果我**设置了动态获取IP**，那么我的笔记的操作系统将生成一个**DHCP请求报文**（应用层），并将这个报文放入一个**UDP报文段**（运输层）注意，是**UDP报文段**，这个UDP报文段主要携带了：

- 目的地端口67（DHCP服务器的固定端口）
- 源端口68（DHCP客户端的固定端口）

然后**UDP报文段**被放入一个**IP数据报**（网络层），IP数据报添加了以下信息：

- 源IP地址：0.0.0.0
- 目的IP地址：255.255.255.255（广播IP目的地址）

2）包含DHCP请求的IP数据报将被放入以太网帧（数据链路层），具有如下信息：

- 目的MAC地址：FF:FF:FF:FF:FF:FF（广播帧）
- 源MAC地址：我的笔记本的MAC地址xx:xx:xx:xx:xx:xx

3） 包含DHCP请求的广播以太网帧是一个从我的笔记本发送到交换机的帧，该交换机在它的所有出口广播这个帧，出口包括连接到路由器的端口（这个很重要）。

4）路由器在它的与交换机直连的端口收到了该广播以太网帧，开始解析该帧，抽取出IP数据报，该数据报的目的IP地址是一个特殊地址（广播IP），因为该数据报应该交付给上层协议处理，因为该数据报的载荷（UDP报文段）被分解向上提交给传输层，传输层中抽取出了DHCP请求交付给应用层，因此DHCP服务器便收到了该DHCP请求。

5）DHCP服务器为此生成一个DHCP ACK报文，该报文包括以下信息：

- 分配给DHCP请求的IP地址
- DNS服务器的IP地址
- 默认网关的IP地址
- 子网块（掩码）

该AC报文被移交给运输层，封装成UDP报文段，再移交给网络层，封装成IP数据包，最后移交给数据链路层，封装成以太网帧；以太网帧的目的MAC地址便是我笔记本的MAC地址，源MAC地址便是接收以太网帧的路由器端口的MAC地址。

6）包含DHCP ACK的以太网帧由路由器发送给了交换机。因为交换机是**自学习**的，并且之前已经收到过了包含DHCP的以太网帧，因此记录了的笔记本的MAC地址，因此它知道向哪个端口转发收到的包含DHCP ACK的以太网帧。

7）当该以太网到达我的笔记本时，从协议栈的数据链路层到应用层，层层抽离，最后得到IP地址、DNS服务器的地址、默认网关。现在我的笔记本已经拿到看足以让我开始冲浪的网络配置了。

------

## 仍在准备：DNS和ARP

现在开始我要开始代开浏览器，来访问网页了，加入我输入的URL为www.google.com。然后一串网络事件又发生了。我的本本将与google服务器进行通信，我们知道通信是两个进程之间的相互发送报文故事，而且进程是通过套接字（socket）接口向网络发送和从网络接收报文的。

为了生成套接字，需要制定目的主机的IP地址，也就是google.com的IP地址，目前我们只知道www.google.com，也就是只知道域名，为了发送HTTP请求（发送IP数据报），还需要知道google.com的IP地址，因为需要一次域名/IP地址转换，也就是DNS。

8）为此，我的本本操作系统生成了一个DNS查询报文，该报文含有如下信息：

- 域名：www.google.com
- DNS服务器目的端口：53

9）随后就是对该运输层报文，经有网络层封装成IP数据报，指定了DNS服务器所在的IP地址；然后就是以太网帧。该帧将被发送给我们已经拿到的**默认网关**路由器。

10）事情看起来好像就可以了，但仔细想想，我们虽然知道了默认网关的IP地址，但是不知道它的MAC地址啊，没有MAC地址，就没有组装以太网帧了。为了我的本本还需要获取该IP地址。我们知道ARP协议：ARP协议是已知IP地址找MAC地址的协议。因此将经过类似上面的DHCP请求，发送一个ARP查询报文，最终经过类似的周折，得到默认网关路由器的MAC地址，这下才可以组装我们的即将发送的以太网帧。

11）得到默认网关的MAC地址后，我的本本就发送了DNS查询请求的以太网帧，该帧当然是会达到默认网关，而默认网关发现其目的IP是DNS服务器的IP地址，即根据转发表，向相应的端口转发。

12）经过类似的路由转发，该DNS查询请求的以太网帧进入ISP，在ISP内将使用域内协议（如RIP、OSPF等）和域间协议BGP，最终到达DNS服务器，服务器自下而上得到DNS查询请求报文，得到www.google.com，然后查找DNS记录，得到对应的IP地址，然后发送一个返回的DNS 响应报文，通过封装成UDP报文段，再到IP数据报，再到以太网帧，最终到达我的本本。然后我的本本就可以正式发起对www.google.com的请求啦，有了IP地址之后，顺利组装以太网帧，发给默认网关。（注意，我们并不需要知道google.com的MAC地址啊，只需要默认网关的）

------

## 终于冲浪：TCP和HTTP

13）有了IP地址之后，客户端进程生成TCP套接字，向www.google.com发起HTTP请求。

14）生成套接字时，首先需要与google.com服务器进行**TCP三次握手**，建立TCP连接。

- TCP SYN请求报文段：几番周折到达google.com
- TCP SYN ACK：来自服务器端的应答
- TCP SYN再次请求，表示我要开始了

15）建立TCP连接之后，就可以开始发送请求了。HTTP GET请求报文段被放入套接字，然后移交给运输层、网络层、数据链路层，经过以太网的路由转发到达google.com服务器。

16）google.com服务器，发送响应报文，blablabla，到达我的本本，然后就有网页显示了。